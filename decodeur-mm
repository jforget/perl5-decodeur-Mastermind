#!/usr/bin/perl
# -*- encoding: utf-8 -*-
#
# Décodeur mastermind
#
# Copyright 2011 Jean Forget


=encoding utf8

=head1 NOM

decode-mm -- un programme pour jouer au Mastermind en tant que décodeur

=head1 UTILISATION

À écrire

=head1 PARAMÈTRES D'APPEL

=over 4

=item * couleurs

Nombre de  couleurs disponibles pour  le code et les  propositions. Ce
nombre doit être compris entre 3  et 26. Les couleurs sont en fait les
lettres de l'alphabet.  Donc, pour 3 couleurs, on  dispose de 'A', 'B'
et 'C', tandis  que pour 26 couleurs on dispose  de toutes les lettres
de 'A' à 'Z'.

=item * trous

Nombre de trous, c'est-à-dire longueur du code à découvrir et longueur
des propositions. Ce nombre doit être compris entre 2 et 5.

=item * reponse

Code  secret à  découvrir. Mais  c'est  promis, le  programme ne  s'en
servira  pas pour  effectuer  ses déductions.  Si  vous fournissez  ce
paramètre, le programme l'utilisera  pour noter les propositions qu'il
joue.  Si vous  ne  le  fournissez pas,  le  programme vous  affichera
chacune des propositions qu'il joue et vous demandera à chaque fois de
donner la note correspondante.

=back

=head1 DESCRIPTION

=head2 Avant-propos

La description qui suit fait  référence à plusieurs occasions au livre
I<Le Mastermind en 10 leçons>,  écrit par Marco Meirovitz (le créateur
du  Mastermind)  et  Jean   Tricot,  publié  par  Hachette  et  achevé
d'imprimer  le  15  février  1979.  Sur Internet,  on  trouve  parfois
M. Meirovitz avec le prénom  Mordechai au lieu de Marco. Remarquez que
dans  les deux  cas,  les  initiales restent  "MM".  Je continuerai  à
l'appeler Marco, puisque c'est ce qui est écrit sur le livre.

Avertissement pour les mathophobes. Si la simple mention d'un sinus ou
d'un cosinus vous  donne des boutons, arrêtez de lire  ce texte. Il ne
sera  pas  question  de  trigonométrie,  mais de  probabilités  et  de
logarithmes,   ce   qui  est   tout   aussi   nocif   à  votre   santé
psychosomatique.

=head2 Rappel sur les règles du jeu

Le Mastermind  se joue à  deux joueurs, le  codeur et le  décodeur. Le
codeur  choisit un  code secret,  une combinaison  de  quatre couleurs
prises  parmi six,  les  répétitions étant  autorisées.   Il pose  les
quatre  pions correspondant dans  quatre trous,  masqués du  regard du
décodeur par un écran amovible.  Puis le décodeur essaie de deviner le
code secret  en proposant une combinaison  de son choix.   Il pose les
quatre  pions colorés  de sa  proposition dans  quatre  trous alignés,
visibles par  les deux joueurs.   Le codeur compare  cette combinaison
avec son code secret et révèle  au décodeur combien de couleurs sont à
la  bonne place  (ce qui  se matérialise  par des  marques  noires) et
combien de couleurs sont correctes,  mais à une mauvaise place (ce qui
donne des  marques blanches).  Si le décodeur  n'a pas trouvé  le code
secret,  il  effectue un  nouveau  tour,  avec  le choix  d'une  autre
combinaison et  le codeur répond  de même. Le  but du décodeur  est de
trouver le code  secret, ce qui se traduit  par quatre marques noires,
avec le minimum de coups.

Exemple : le codeur a choisi

  C F E D

et le décodeur propose

  A B C D

La  note se  constitue  d'une  marque noire  (pour  C<D> en  quatrième
position) et d'une marque blanche (pour C<C> en première position dans
le  code  et en  troisième  position  dans  la proposition).  Mais  le
décodeur  ne sait pas  quelle couleur  ou quelle  position a  donné la
marque noire ni la marque blanche.

S'il y  a répétition de  couleur, un même  pion ne peut  donner qu'une
seule   marque,   en  privilégiant   les   marques   noires  sur   les
blanches. Exemple :

  code secret   D A A D
  proposition   A B C D

Le résultat sera une marque noire et une marque blanche. Le C<A> de la
proposition, en position 1, peut être apparié au C<A> en position 2 du
code secret  ou à celui  qui se trouve  en position 3.  Dans  les deux
cas,  cela donne  une marque  blanche.   Mais cela  n'en donne  qu'une
seule, le C<A> de la  proposition ne pouvant servir qu'une seule fois.
Le C<D>  de la proposition, en  position 4, peut être  apparié avec le
C<D>  en  position 1  du  code secret,  ce  qui  donnerait une  marque
blanche,  ou  avec le  C<D>  en  position 4  du  code  secret, ce  qui
donnerait une  marque noire.  Dans ce cas,  c'est la marque  noire qui
l'emporte sur  la marque  blanche.  Le résultat  complet est  donc une
marque noire et une marque blanche.

Si le codeur  est obligé de choisir ses quatre  couleurs parmi les six
possibles, le  décodeur a le  droit d'insérer dans sa  proposition une
couleur  dont il sait  qu'elle est  invalide. Matériellement,  cela se
traduit par une place laissée vide, sans pion de couleur.

Dans le cas d'un texte en noir sur blanc (ce fichier POD ou un livre),
on représente  traditionnellement les marques  noires avec un  C<X> et
les  marques  blanches avec  un  C<O>.   Les  pions de  couleurs  sont
habituellement  représentés  par l'initiale  de  la  couleur, mais  je
préfère ici utiliser les lettres de C<A> à C<F>, puisque j'envisage de
permettre l'utilisation d'un nombre de couleurs allant jusqu'à 26.

Il  existe des  variantes  du Mastermind.  Des variantes  élémentaires
consistent à faire varier le nombre de trous et le nombre de couleurs.
Elles  sont traitées (dans  des limites  raisonnables) par  le présent
programme.

D'autres variantes sont destinées à simplifier la tâche du décodeur et
ne  requièrent aucun  matériel  supplémentaire. Par  exemple, le  code
secret  doit  contenir quatre  couleurs  différentes, les  répétitions
étant interdites. Ou bien le codeur doit indiquer au décodeur à quelle
position  correspond chaque marque  noire ou  blanche qu'il  pose. Ces
variantes ne sont pas prises en compte dans le présent programme.

Enfin, d'autres variantes changent les mécanismes du jeu : utilisation
de formes en plus des couleurs, utilisation de lettres, le code secret
devant être  un mot intelligible  en français, etc.  Ces  variantes ne
sont pas prises en considération dans le présent programme.

=head2 Déroulement d'une partie

Une partie  avec un décodeur  humain se déroule  en trois étapes  : le
début de partie, le milieu de partie et la fin de partie.

Pendant le  début de partie, le  décodeur n'a aucune idée  sur le code
secret à  trouver. Il joue donc  des propositions en  grande partie au
hasard, de manière à « ratisser large ».

En milieu de  partie, le décodeur commence à  avoir quelques idées sur
le code secret,  il formule des hypothèses et  les teste. Par exemple,
il peut  formuler des hypothèses comme  : « Le rouge  est-il répété ou
n'apparaît-il qu'une fois  ? » ou bien : « La  marque noire du premier
tour  correspond-elle au  bleu en  première  position ou  au jaune  en
troisième ? ».

En fin de partie, le décodeur  a des idées précises sur le code secret
et il ne  reste plus que quelques codes compatibles avec  ce qui a été
joué jusque-là.   Le décodeur est  capable d'énumérer la liste  de ces
codes. Son but est alors de  minimiser le nombre de coups à jouer pour
obtenir le  résultat, donc de  choisir dans la  liste le code  le plus
discriminant.  Exemple, les codes  restants sont : C<ABCD>, C<ABDC> et
C<BACD>. Si le décodeur joue C<ABCD>, le codeur répondra :

=over 4

=item * C<XXXX> si le code secret est C<ABCD>

=item * C<XXOO> si le code secret est C<ABDC> ou C<BACD>.

=back

Si en revanche, le décodeur joue C<BACD>, le codeur répondra :

=over 4

=item * C<XXXX> si le code secret est C<BACD>,

=item * C<XXOO> si le code secret est C<BADC>,

=item * C<OOOO> si le code secret est C<BACD>.

=back

On voit donc  que C<BACD> mène à un gain en  deux coups maximum, alors
que dans  un tiers  des cas, C<ABCD>  conduit à  une fin de  partie en
trois coups.

Dans le  cas de mon  programme, le milieu  de partie n'existe  pas. Le
programme est capable de mémoriser  une liste de plusieurs dizaines de
codes autorisés, ce  que ne peut pas faire un  humain normal.  Donc, à
l'issue  du  début  de   partie,  pendant  un  interlude  (de  "inter"
signifiant "entre" et "lude" signifiant "jeu") le programme établit la
liste  des codes  compatibles avec  ce qui  a déjà  été joué,  puis il
entame la fin de la partie.

Une autre différence entre mon programme et le jeu avec un humain.  Le
programme  considère   que  tous  les   codes  secrets  ont   la  même
probabilité.  Ainsi que le signalent  les auteurs, si le codeur est un
humain, il  évitera inconsciemment certaines  combinaisons de couleurs
et  en privilégiera  d'autres. Également,  les codes  monochromes sont
censés survenir 6 fois sur 1296, ou 1 fois sur 216 si le codeur est un
programme correctement  codé, alors  que la proportion  sera nettement
moins importante si le codeur est un humain.

=head2 Début de partie

Le  livre de  Jean Tricot  et Marco  Meirovitz analyse  les différents
coups de départ pour le jeu à 4 trous et 6 couleurs et pour le jeu à 4
trous  et 7  couleurs.   Pour le  jeu à  4  trous et  6 couleurs,  les
propositions  C<ABCD>  et  C<ABCC>  sont quasiment  équivalentes.   En
revanche, pour le  jeu à 4 trous et 7 couleurs,  c'est le code C<ABCD>
qui  est  le  meilleur.   Donc,  par  extrapolation  pifométrique,  je
considère que la meilleure tactique  pour le début de partie lorsqu'il
y a beaucoup de couleurs  consiste à jouer C<ABCD>, puis C<EFGH>, puis
C<IJKL> et  ainsi de suite.  Et s'il n'y  a pas assez de  couleurs, on
boucle. Par exemple,  pour le jeu à 4 trous et  6 couleurs, le premier
coup  est C<ABCD>,  le  deuxième est  C<EFAB>,  c'est-à-dire les  deux
dernières couleurs C<E> et C<F>, puis on reprend au début avec C<A> et
C<B> pour compléter le code.

Tout  au long  du début  de partie,  si l'on  tombe sur  un  nombre de
marques à zéro, on supprime  carrément de la liste des couleurs celles
qui apparaissent dans la proposition. Cela accélérera l'interlude.

=head2 Interlude

Dans l'interlude,  le programme construit  la liste de tous  les codes
compatibles avec les coups joués pendant le début de partie.  La liste
est construite progressivement avec des  codes incomplets à 1, puis 2,
puis 3 pions, avant d'arriver aux codes complets à 4 pions.

À chaque  étape, on  compare le code  incomplet avec  les propositions
jouées dans le début de partie,  pour voir si les résultats (nombre de
marques noires et nombre de marques blanches) correspondent.  On garde
à l'esprit que le code est incomplet et qu'en le ajoutant une couleur,
on peut :

=over 4

=item * obtenir une marque noire supplémentaire,

=item * obtenir une marque blanche supplémentaire,

=item * remplacer une marque blanche par une marque noire.

=back

Pour un code à trois couleurs  et un vide, le nombre de marques noires
doit  donc être  le nombre  final, ou  bien le  nombre final  moins 1.
Quant à  tester les  marques blanches, il  est préférable de  faire la
somme noirs+blancs. Ainsi, le nombre  de marques noires et blanches du
code à trois couleurs et un  vide doit être le nombre final de marques
noires et blanches, ou bien ce nombre moins 1.

Pour  un code  à deux  couleurs et  deux vides,  le nombre  de marques
noires  doit être compris  entre le  nombre final  et le  nombre final
moins 2.  Idem pour la somme marques noires + marques blanches.

Et pour  un code  à une seule  couleur  et  trois vides, le  nombre de
marques noires  doit être compris entre  le nombre final  et le nombre
final moins 3.  Et encore une fois, c'est pareil pour le nombre cumulé
de marques noires et blanches.

Ainsi, en commençant  par déterminer les codes à un  seul pion, puis à
deux pions, puis 3 puis 4, on ne parcourt pas l'arbre entier des codes
possibles, on  l'élague au fur  et à mesure,  ce qui permet  de perdre
moins de temps.

Exemples : l'un  des coups joués était C<ABCD>,  noté C<X> (une marque
noire). Le code C<AE..> obtient  une note C<X> et est donc compatible.
Le  code C<AD..>  obtient une  note  C<XO> est  est incompatible.   En
effet,  quelles  que  soient  les  couleurs placées  en  troisième  et
quatrième positions,  on ne  pourra pas revenir  à une note  C<X>.  Le
code C<CE..> obtient une note C<O> et est compatible. Bien qu'il y ait
une marque blanche en trop, cette marque pourra être remplacée par une
marque  noire, lorsque l'on  testera C<CEC.>  puis C<CECC>  et C<CECE>
(entre autres).

Maintenant, supposons que le coup C<ABCD> ait reçu la note C<XOO> (une
marque noire et deux blanches). Le code C<AE..> reçoit la note C<X> et
est compatible.  En effet, il reste  deux trous à remplir  et ces deux
trous  peuvent  fournir  les  deux marques  blanches  manquantes.   En
revanche, le code  C<EF..> reçoit une note nulle  et est incompatible.
En effet,  ce n'est pas  les deux trous  à remplir qui  permettront de
fournir les trois marques manquantes.

Une fois  la liste  des codes construite,  le programme  évalue chaque
code avec  chaque autre, pour stocker  la note dans  un hachage indexé
par ces deux codes. Comme cela sera montré dans la suite, le programme
aura besoin de toutes ces notes  au moins une fois, mais assez souvent
plusieurs fois. À cause de cette étape, on souhaite avoir une liste de
codes  suffisamment  petite.   Il   aurait  été  possible  de  stocker
plusieurs centaines de codes possible dans la liste, mais pour l'étape
présente,  cela  aurait  impliqué  une  boucle avec  des  dizaines  de
milliers  d'itérations.   On préfère  donc,  autant  que possible,  se
limiter à quelques dizaines de codes possibles.

=head2 Fin de partie

Un coup de la fin de la partie prend l'allure suivante :

=over 4

=item *  Le programme choisit le  code le plus  discriminant parmi les
codes restants,

=item * Le programme joue ce code,

=item * Si la note est C<XXXX>, fin de la partie

=item *  Sinon, le  programme reçoit  la note du  codeur et  filtre la
liste des  codes restants pour  éliminer les codes  incompatibles avec
cette note.

=back

L'action de jouer un code et l'action de filtrer les codes restants ne
présentent pas de mystère. Le choix du code le plus discriminant parmi
les  codes restants  est plus  intéressant. Il  y  principalement deux
méthodes. Celle que j'ai connue la première pendant les années 1980 et
qui est  mentionnée dans  le livre de  Jean Tricot et  Marco Meirovitz
repose sur  l'entropie de Shannon. La  seconde, dont j'ai  eu vent fin
2011 en  lisant la doc  de C<Algorithm::Mastermind> a été  décrite par
Donald Knuth et utilise le minimax.

=head3 L'entropie de Shannon

Au début, l'entropie a été un concept en physique, plus précisément en
thermodynamique.    L'entropie   a   été   introduite   par   Clausius
(1822--1888)  comme étant  le quotient  de la  quantité de  chaleur du
système  considéré par  sa  température absolue.  Cette  notion a  été
développée  par Ludwig  Boltzmann (1844--1906)  qui  l'a.décrite comme
étant le  nombre de micro-états définissant le  macro-état du système.
Shannon  (1916--2001)  a repris  cette  notion  en mathématiques  pour
étudier le codage  optimal d'un message transmis par  un canal avec ou
sans parasites. La formule qu'il donne est

  - sigma(pi x Log2(pi))

Jean Tricot et Marco Meirovitz  ont appliqué ce concept au Mastermind,
mais sans  vraiment donner  de détails.  Voici  une explication  de la
notion  d'entropie mathématique.  Cela ne  constitue pas  un  cours de
mathématiques en bonne et due  forme, c'est plutôt une présentation de
mathématiques expérimentales faisant  appel à l'intuition plutôt qu'au
raisonnement.

Laissons de côté le Mastermind et prenons un autre jeu sur le principe
des  questions-réponses, le  jeu consistant  à deviner  un  nombre. Le
codeur choisit secrètement un nombre entre 1 et 100 et le décodeur lui
propose un  nombre, par exemple 50.  Le codeur doit  alors répondre si
c'est  ce nombre,  ou bien  un nombre  plus petit,  ou bien  encore un
nombre plus  grand. Maintenant, modifions légèrement les  règles de ce
jeu. D'une  part, le  nombre à deviner  est dans  l'intervalle 0..255,
d'autre part les questions sont en format libre.

Le décodeur commence par la question : « Le nombre se trouve-t-il dans
l'intervalle 0..127 ou dans l'intervalle  128..255 ? » Dans un cas sur
deux, il  apprendra que le bit  de poids fort  est 0, dans un  cas sur
deux il apprendra  que c'est 1. Avec les  deux réponses de probabilité
1/2, le décodeur gagnera donc 1 bit.

Supposons  maintenant que  sa première  question  soit :  « Le  nombre
est-il pair  ou impair ? ». Là  encore l'une ou l'autre  réponse a une
probabilité de  1/2 et l'une ou  l'autre fait gagner un  bit, sauf que
c'est le bit de poids faible.

Et maintenant, le  décodeur commence la partie par la  question : « Le
nombre se  trouve-t-il dans l'intervalle  0..63 ? ». S'il  obtient une
réponse affirmative, il aura gagné deux bits. Mais cette réponse a une
probabilité de 1/4. Ou bien alors,  il pourrait même commencer par : «
Est-ce 23 ? » et cette réponse, de probabilité 1/256 lui ferait gagner
8 bits d'un seul coup.

Et  s'il demande  maintenant :  « Le  nombre est-il  dans l'intervalle
0..84 ? », une réponse affirmative lui permet de connaître précisément
le bit  de poids  fort et  d'avoir de fortes  présomptions sur  le bit
suivant. En tout état  de cause le nombre commence par C<0>  et il y a
de fortes chances qu'il commence par  C<00>. Il a donc gagné plus d'un
bit,  mais  pas  tout-à-fait  2.  On  va dire  que  cette  réponse  de
probabilité 1/3  lui a fait gagner  1,58 bit. On en  déduit le tableau
suivant :

  +------------+------------+
  | probabilité| information|
  | de la      | obtenue    |
  | réponse    |            |
  +------------+------------+
  |    1/2     |   1 bit    |
  +------------+------------+
  |    1/4     |   2 bits   |
  +------------+------------+
  |    1/256   |   8 bits   |
  +------------+------------+
  |    1/3     | 1,58 bit   |
  +------------+------------+
  |    p_i     | -Log_2(p_i)|
  +------------+------------+

Une question peut  être considérée comme un éventail  de réponses plus
ou  moins probables. Supposons  que la  première question  du décodeur
soit  : «  Le  nombre  se trouve-t-il  dans  l'intervalle 0..63,  dans
l'intervalle 64..127  ou dans l'intervalle  128..255 ? ».  La première
réponse  lui fournit  2 bits  avec  une probabilité  1/4. La  deuxième
réponse  lui fournit  aussi  2 bits  avec  une probabilité  1/4 et  la
troisième  réponse lui  fournit 1  bit  avec une  probabilité 1/2.  Le
décodeur récoltera en moyenne  1/4 x 2 + 1/4 x 2 + 1/2  x 1 = 1,5 bit.
Plus généralement,  si les probabilités des  différentes réponses sont
(p_i), alors la quantité d'information moyenne obtenue par la question
est :

  - sigma(p_i x Log2(p_i))

Pour faire  pédant, signalons que  l'on peut utiliser  les logarithmes
népériens dans la formule à la  place des logarithmes à base deux.  On
ne peut plus parler de bits dans ce cas. L'unité est alors appelé le «
shannon ». Cette unité de quantité d'information n'est jamais utilisée
dans  la  réalité,  y  compris  pour  les  études  théoriques  sur  la
transmission de l'information.

Revenons au Mastermind. Une question consiste à jouer une proposition,
C<ABCD>  ou  C<BACD> par  exemple.  La  réponse  est l'une  des  notes
C<XXXX>, C<XXOO>, C<XXX.>, C<XOO> et ainsi de suite. La probabilité de
chacune de ces  réponses est proportionnelle au nombre  de codes qui y
correspondent.  On peut ainsi calculer l'entropie de la question.

Reprenons  l'exemple du  début.  Les codes  restants  sont :  C<ABCD>,
C<ABDC> et C<BACD>. Si le décodeur joue C<ABCD>, le codeur répondra :

  +----------+----------+--------------+-------------+------------+
  | Question | Réponses | Codes        | Probabilité | Entropie   |
  +----------+----------+--------------+-------------+------------+
  |   ABCD   |   XXXX   | ABCD         |    1/3      |            |
  |          +----------+--------------+-------------+            |
  |          |   XXOO   | ABDC et BACD |    2/3      |  0,92 bit  |
  +----------+----------+--------------+-------------+------------+
  |   BACD   |   XXXX   | BACD         |    1/3      |            |
  |          +----------+--------------+-------------+            |
  |          |   XXOO   | ABCD         |    1/3      |            |
  |          +----------+--------------+-------------+            |
  |          |   OOOO   | ABDC         |    1/3      |  1,58 bit  |
  +----------+----------+--------------+-------------+------------+
  |   ABDC   |   XXXX   | ABDC         |    1/3      |            |
  |          +----------+--------------+-------------+            |
  |          |   XXOO   | ABCD         |    1/3      |            |
  |          +----------+--------------+-------------+            |
  |          |   OOOO   | BACD         |    1/3      |  1,58 bit  |
  +----------+----------+--------------+-------------+------------+

On voit  donc que le code  C<BACD> et le code  C<ABDC> rapportent plus
d'information que C<ABCD>.  C'est donc ce que le programme de décodage
jouera.

=head3 Le minimax de Knuth

Ce  critère est  nettement plus  simple  (et beaucoup  moins rigolo  à
expliquer). Lorsque  l'on recense  les différentes notes  obtenues pas
les  codes possibles  restants,  on  se contente  de  retenir la  note
correspondant au nombre maximal de codes possibles. Et le code à jouer
est  celui pour  lequel ce  maximum est  le plus  petit. Avec  le même
exemple que ci-dessus, on a :

  +----------+----------+--------------+--------+---------+
  | Question | Réponses | Codes        | Nombre | Maximum |
  +----------+----------+--------------+--------+---------+
  |   ABCD   |   XXXX   | ABCD         |    1   |         |
  |          +----------+--------------+--------+         |
  |          |   XXOO   | ABDC et BACD |    2   |    2    |
  +----------+----------+--------------+--------+---------+
  |   BACD   |   XXXX   | BACD         |    1   |         |
  |          +----------+--------------+--------+         |
  |          |   XXOO   | ABCD         |    1   |         |
  |          +----------+--------------+--------+         |
  |          |   OOOO   | ABDC         |    1   |    1    |
  +----------+----------+--------------+--------+---------+
  |   ABDC   |   XXXX   | ABDC         |    1   |         |
  |          +----------+--------------+--------+         |
  |          |   XXOO   | ABCD         |    1   |         |
  |          +----------+--------------+--------+         |
  |          |   OOOO   | BACD         |    1   |    1    |
  +----------+----------+--------------+--------+---------+

On voit que  comme avec l'entropie de Shannon, il  ne faut surtout pas
jouer C<ABCD>, mais soit C<BACD>, soit C<ABDC>.

Dans un cas aussi simple, ce  n'est pas étonnant que les deux critères
aboutissent au même résultat. Dans un cas plus compliqué, cela ne sera
pas toujours  le cas. Ainsi, en  annexe de leur livre,  Jean Tricot et
Marco  Meirovitz analysent  le premier  coup  du jeu  à 4  trous et  6
couleurs. Le  coup C<ABCD> possède  la meilleure entropie,  3,05 bits,
mais pour  un nombre maximal de  312 codes avec la  note C<OO>, tandis
que le coup C<ABCC> est meilleur  pour le critère de Knuth, la note la
moins  bonne,  C<O>  donnant  276 possibilités  restantes,  alors  que
l'entropie  de Shannon  pour C<ABCC>  est moins  bonne, 3,04  bits. Un
centième de bit,  cela ne va pas chercher très  loin, mais le résultat
est là, ces deux critères ne sont pas forcément en accord.

Quel  est le meilleur  critère ?  Je ne  sais pas.  Je pense  que cela
dépend des  circonstances et que l'entropie se  révèlera meilleure que
le  minimax  dans certains  cas  tandis  que  le minimax  se  révèlera
meilleur que l'entropie  dans d'autres cas. Notons que  l'on n'est pas
obligé d'utiliser la  même méthode tout au long  d'une même partie. On
peut jouer un coup avec le minimax et le suivant avec l'entropie.

=head1 CONFIGURATION ET ENVIRONNEMENT

Néant.

=head1 DÉPENDANCES

À écrire

=head1 INCOMPATIBILITÉS

Aucune incompatibilité identifiée.

=head1 BOGUES ET LIMITES

Pour l'instant, aucun n'a été identifié.

=head1 AUTEUR

Jean Forget, JFORGET (à) cpan.org

=head1 LICENCE ET COPYRIGHT

(C) Jean Forget, 2011, tous droits réservés.

Les termes de licence de ce script sont les mêmes termes que pour Perl
: GNU General Public License (GPL) et Artistic License.


=cut

use v5.10;
use strict;
use warnings;
use Getopt::Long;

my (@coul, $nb_coul, $nb_trous, $reponse);
GetOptions("couleurs=i" => \$nb_coul,
           "trous=i"    => \$nb_trous,
           "reponse=s"  => \$reponse,
  ) or die "Problème avec les options";

$nb_coul  //= 6;
$nb_trous //= 4;
$reponse  //= '';
die "Nombre de trous de 2 à 5"
  unless $nb_trous >= 2 && $nb_trous <= 5;
die "Nombre de couleurs de 3 à 26"
  unless $nb_coul >= 3 && $nb_coul <= 26;

@coul = ('A'..'Z')[0..$nb_coul-1];
# say join ' ', @coul;

$reponse = uc $reponse;

if ($reponse ne '') {
  die "Réponse '$reponse' trop courte ($nb_trous trous)"
    unless length($reponse) >= $nb_trous;
  die "Réponse '$reponse' trop longue ($nb_trous trous)"
    unless length($reponse) == $nb_trous;

  # vérification du contenu de la réponse
  if ($reponse !~ join '', '^[', @coul, ']*$') {
    die "Couleur incorrecte dans '$reponse'";
  }
}

my @partie;
my @poss;

debut_de_partie()
|| interlude()
|| fin_de_partie();
exit(0);

sub debut_de_partie {
  my $pointeur = - $nb_coul;
  while ($pointeur < 0) {
    my $prop = join '', @coul[$pointeur .. $pointeur + $nb_trous - 1];
    my ($n, $b, $nb, $res) = jouer($prop);
    if ($n == $nb_trous) {
      say "Gagné ! mais j'ai eu de la chance...";
      return 1;
    }
    if ($nb == 0) {
      splice @coul, $pointeur, $nb_trous;
      say join ' ', @coul;
    }
    push @partie, { prop => $prop, n => $n, b => $b, nb => $nb, res => $res };
    $pointeur += $nb_trous;
  }
  return 0;
}

sub interlude {
  @poss = ( '.' x $nb_trous );

  # $i représente aussi bien l'emplacement où l'on insère la couleur que le nombre de places
  # inoccupées dans la génération courante. C'est pour cela que l'on fait une boucle
  # descendante.
  for my $i (reverse (0 .. $nb_trous - 1)) {
    my @poss_prec = @poss;
    @poss = ();
    for my $coul (@coul) {
      for my $poss (@poss_prec) {
        my $compatible = 1;
        substr($poss, $i, 1) = $coul;

        for my $coup (@partie) {
          my ($n, undef, $nb) = noter($coup->{prop}, $poss);
          if ($n > $coup->{n} || $nb > $coup->{nb}) {
            # La proposition incomplète est déjà trop bien notée
            $compatible = 0;
            last;
          }
          if ($n < $coup->{n} - $i || $nb < $coup->{nb} - $i) {
            # La proposition incomplète est trop en retard par rapport à la note du coup
            $compatible = 0;
            last;
          }
        }

        if ($compatible) {
          push @poss, $poss;
        }
      }
    }
    say join ' ', @poss
  }
  if (@poss == 0) {
    say "Il y a une incohérence quelque part. Pouvez-vous vérifier les notes, s'il-vous-plaît ?";
    return 1;
  }
  die "Deuxième partie de l'interlude pas encore codée";
}

sub fin_de_partie {
  die "fin_de_partie : pas encore codé";
}

sub jouer {
  my ($prop) = @_;
  if ($reponse ne '') {
    my ($n, $b, $nb, $res) = noter($prop, $reponse);
    say $prop;
    say "n = $n, b = $b, nb = $nb";
    return ($n, $b, $nb, $res);
  }
  my $pas_bon = 1;
  while ($pas_bon) {
    say $prop;
    my ($n, $b, $nb, $res);

    my $resultat = <STDIN>;
    chomp $resultat;
    $resultat = uc $resultat;

    if ($resultat eq '') {
      print <<"EOF";
Résultat de la forme '1 2' ou 'XOO' pour un noir et deux blancs.
Si la réponse est 0 noir et 0 blanc, tapez au moins un espace pour éviter une erreur de saisie.
EOF
      next;
    }
    elsif ($resultat =~ /^(\d)\s+(\d)\s*$/) {
      $n   = $1;
      $b   = $2;
      $nb  = $n + $b;
      $res = 'X' x $n . 'O' x $n;
    }
    elsif ($resultat eq ' ') {
      $n   = 0;
      $b   = 0;
      $nb  = 0;
      $res = '';
    }
    elsif ($resultat =~ /^(X*)(O*)$/) {
      $n   = length($1);
      $b   = length($2);
      $nb  = $n + $b;
      $res = $1 . $2;
    }
    else {
      print <<"EOF";
Réponse incorrecte.
Résultat de la forme '1 2' ou 'XOO' pour un noir et deux blancs.
Si la réponse est 0 noir et 0 blanc, tapez au moins un espace pour éviter une erreur de saisie.
EOF
      next;
    }
    if ($n > $nb_trous) {
      say "Réponse incorrecte, le nombre de noirs ($n) ne peut pas dépasser le nombre de trous ($nb_trous)";
      next;
    }
    if ($b > $nb_trous) {
      say "Réponse incorrecte, le nombre de blancs ($b) ne peut pas dépasser le nombre de trous ($nb_trous)";
      next;
    }
    if ($nb > $nb_trous) {
      say "Réponse incorrecte, le nombre de noirs et de blancs ($nb) ne peut pas dépasser le nombre de trous ($nb_trous)";
      next;
    }
    $pas_bon = 0;
    say "n = $n, b = $b, nb = $nb";
    return ($n, $b, $nb, $res);
  }
}

sub noter {
  my ($prop1, $prop2) = @_;
  my ($n, $b, $nb, $res) = (0, 0, 0, '');

  #say $prop1;
  for (my $i = 0; $i < $nb_trous; $i++) {
    if (substr($prop1, $i, 1) eq substr($prop2, $i, 1)) {
      $n   ++;
      $nb  ++;
      $res .= 'X';
      substr($prop1, $i, 1) = chr(1);
      substr($prop2, $i, 1) = chr(2);
    }
  }
  for (my $i = 0; $i < length($prop1); $i++) {
    for (my $j = 0; $j < length($prop2); $j++) {
      if (substr($prop1, $i, 1) eq substr($prop2, $j, 1)) {
        $b   ++;
        $nb  ++;
        $res .= 'O';
        substr($prop1, $i, 1) = chr(1);
        substr($prop2, $j, 1) = chr(2);
      }
    }
  }
  #say "n = $n, b = $b, nb = $nb";
  return ($n, $b, $nb, $res);
}
