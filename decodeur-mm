#!/usr/bin/perl
# -*- encoding: utf-8 -*-
#
# Décodeur mastermind
#
# Copyright 2011 Jean Forget

die "Le programme n'est pas prêt pour l'instant, revenez un peu plus tard\n";


__END__

=encoding utf8

=head1 NOM

decode-mm -- un programme pour jouer au Mastermind en tant que décodeur

=head1 UTILISATION

À écrire

=head1 PARAMÈTRES D'APPEL

À écrire

=head1 DESCRIPTION

=head2 Avant-propos

La description qui suit fait  référence à plusieurs occasions au livre
I<Le Mastermind en 10 leçons>,  écrit par Marco Meirovitz (le créateur
du  Mastermind)  et  Jean   Tricot,  publié  par  Hachette  et  achevé
d'imprimer  le  15  février  1979.  Sur Internet,  on  trouve  parfois
M. Meirovitz avec le prénom  Mordechai au lieu de Marco. Remarquez que
dans  les deux  cas,  les  initiales restent  "MM".  Je continuerai  à
l'appeler Marco, puisque c'est ce qui est écrit sur le livre.

Avertissement pour les mathophobes. Si la simple mention d'un sinus ou
d'un cosinus vous  donne des boutons, arrêtez de lire  ce texte. Il ne
sera  pas  question  de  trigonométrie,  mais de  probabilités  et  de
logarithmes,   ce   qui  est   tout   aussi   nocif   à  votre   santé
psychosomatique.

=head2 Rappel sur les règles du jeu

Le Mastermind  se joue à  deux joueurs, le  codeur et le  décodeur. Le
codeur  choisit un  code secret,  une combinaison  de  quatre couleurs
prises  parmi six,  les  répétitions étant  autorisées.   Il pose  les
quatre  pions correspondant dans  quatre trous,  masqués du  regard du
décodeur par un écran amovible.  Puis le décodeur essaie de deviner le
code secret  en proposant une combinaison  de son choix.   Il pose les
quatre  pions colorés  de sa  proposition dans  quatre  trous alignés,
visibles par  les deux joueurs.   Le codeur compare  cette combinaison
avec son code secret et révèle  au décodeur combien de couleurs sont à
la  bonne place  (ce qui  se matérialise  par des  marques  noires) et
combien de couleurs sont correctes,  mais à une mauvaise place (ce qui
donne des  marques blanches).  Si le décodeur  n'a pas trouvé  le code
secret,  il  effectue un  nouveau  tour,  avec  le choix  d'une  autre
combinaison et  le codeur répond  de même. Le  but du décodeur  est de
trouver le code  secret, ce qui se traduit  par quatre marques noires,
avec le minimum de coups.

Exemple : le codeur a choisi

  C F E D

et le décodeur propose

  A B C D

La note  se constitue  d'une marque noire  (pour "D") et  d'une marque
blanche (pour  "C"). Mais  le décodeur ne  sait pas quelle  couleur ou
quelle position a donné la marque noire ni la marque blanche.

S'il y  a répétition de  couleur, un même  pion ne peut  donner qu'une
seule   marque,   en  privilégiant   les   marques   noires  sur   les
blanches. Exemple :

  code secret   D A A D
  proposition   A B C D

Le résultat sera une marque noire  et une marque blanche. Le "A" de la
proposition, en position 1, peut être  apparié au "A" en position 2 du
code secret  ou à celui  qui se trouve  en position 3.  Dans  les deux
cas,  cela donne  une marque  blanche.   Mais cela  n'en donne  qu'une
seule, le "A"  de la proposition ne pouvant  servir qu'une seule fois.
Le "D" de la proposition, en position 4, peut être apparié avec le "D"
en position 1 du code secret,  ce qui donnerait une marque blanche, ou
avec le "D" en position 4  du code secret, ce qui donnerait une marque
noire. Dans ce cas, c'est la  marque noire qui l'emporte sur la marque
blanche.  Le résultat complet est  donc une marque noire et une marque
blanche.

Si le codeur  est obligé de choisir ses quatre  couleurs parmi les six
possibles, le  décodeur a le  droit d'insérer dans sa  proposition une
couleur  dont il sait  qu'elle est  invalide. Matériellement,  cela se
traduit par une place laissée vide, sans pion de couleur.

Dans le cas d'un texte en noir sur blanc (ce fichier POD ou un livre),
on représente traditionnellement les marques noires avec un "X" et les
marques   blanches  avec   un  "O".   Les  pions   de   couleurs  sont
habituellement  représentés  par l'initiale  de  la  couleur, mais  je
préfère ici utiliser  les lettres de "A" à  "F", puisque j'envisage de
permettre l'utilisation d'un nombre de couleurs allant jusqu'à 26.

Il  existe des  variantes  du Mastermind.  Des variantes  élémentaires
consistent à faire varier le nombre de trous et le nombre de couleurs.
Elles  sont traitées (dans  des limites  raisonnables) par  le présent
programme.

D'autres variantes sont destinées à simplifier la tâche du décodeur et
ne  requièrent aucun  matériel  supplémentaire. Par  exemple, le  code
secret  doit  contenir quatre  couleurs  différentes, les  répétitions
étant interdites. Ou bien le codeur doit indiquer au décodeur à quelle
position  correspond chaque marque  noire ou  blanche qu'il  pose. Ces
variantes ne sont pas prises en compte dans le présent programme.

Enfin, d'autres variantes changent les mécanismes du jeu : utilisation
de formes en plus des couleurs, utilisation de lettres, le code secret
devant être  un mot intelligible  en français, etc.  Ces  variantes ne
sont pas prises en considération dans le présent programme.

=head2 Déroulement d'une partie

Une partie  avec un décodeur  humain se déroule  en trois étapes  : le
début de partie, le milieu de partie et la fin de partie.

Pendant le  début de partie, le  décodeur n'a aucune idée  sur le code
secret à  trouver. Il joue donc  des propositions en  grande partie au
hasard, de manière à "ratisser large".

En milieu de  partie, le décodeur commence à  avoir quelques idées sur
le code secret,  il formule des hypothèses et  les teste. Par exemple,
il peut  formuler des  hypothèses comme :  "Le rouge est-il  répété ou
n'apparaît-il qu'une  fois ?"  ou bien :  "La marque noire  du premier
tour  correspond-elle au  bleu en  première  position ou  au jaune  en
troisième ?".

En fin de partie, le décodeur  a des idées précises sur le code secret
et il ne  reste plus que quelques codes compatibles avec  ce qui a été
joué jusque-là.   Le décodeur est  capable d'énumérer la liste  de ces
codes. Son but est alors de  minimiser le nombre de coups à jouer pour
obtenir le  résultat, donc de  choisir dans la  liste le code  le plus
discriminant.  Exemple,  les  codes  restants  sont :  ABCD,  ABDC  et
BACD. Si le décodeur joue ABCD, le codeur répondra :

=over 4

=item * XXXX si le code secret est ABCD

=item * XXOO si le code secret est ABDC ou BACD.

=back

Si en revanche, le décodeur joue BACD, le codeur répondra :

=over 4

=item * XXXX si le code secret est BACD,

=item * XXOO si le code secret est BADC,

=item * OOOO si le code secret est BACD.

=back

On voit donc que BACD mène à  un gain en deux coups maximum, alors que
dans  un tiers des  cas, ABCD  conduit à  une fin  de partie  en trois
coups.

Dans le  cas de mon  programme, le milieu  de partie n'existe  pas. Le
programme est capable de mémoriser  une liste de plusieurs dizaines de
codes autorisés, ce  que ne peut pas faire un  humain normal.  Donc, à
l'issue  du  début  de   partie,  pendant  un  interlude  (de  "inter"
signifiant "entre" et "lude" signifiant "jeu") le programme établit la
liste  des codes  compatibles avec  ce qui  a déjà  été joué,  puis il
entame la fin de la partie. Un coup de la fin de la partie prend alors
l'allure suivante :

=over 4

=item *  Le programme choisit le  code le plus  discriminant parmi les
codes restants,

=item * Le programme joue ce code,

=item * Si la note est "XXXX", fin de la partie

=item *  Sinon, le  programme reçoit  la note du  codeur et  filtre la
liste des  codes restants pour  éliminer les codes  incompatibles avec
cette note.

=back

Une autre différence entre mon programme et le jeu avec un humain.  Le
programme  considère   que  tous  les   codes  secrets  ont   la  même
probabilité.  Ainsi que le signalent  les auteurs, si le codeur est un
humain, il  évitera inconsciemment certaines  combinaisons de couleurs
et  en priviligiera  d'autres. Également,  les codes  monochromes sont
censés survenir 6 fois sur 1296, ou 1 fois sur 216 si le codeur est un
programme correctement  codé, alors  que la proportion  sera nettement
moins importante si le codeur est un humain.

=head2 Début de partie

Le  livre de  Jean Tricot  et Marco  Meirovitz analyse  les différents
coups de départ pour le jeu à 4 trous et 6 couleurs et pour le jeu à 4
trous  et 7  couleurs.  Pour  le jeu  à  4 trous  et  6 couleurs,  les
propositions  "ABCD"   et  "ABCC"  sont   quasiment  équivalentes.  En
revanche, pour  le jeu à 4 trous  et 7 couleurs, c'est  le code "ABCD"
qui  est  le  meilleur.   Donc,  par  extrapolation  pifométrique,  je
considère que la meilleure tactique  pour le début de partie lorsqu'il
y a  beaucoup de couleurs consiste  à jouer "ABCD",  puis "EFGH", puis
"IJKL" et  ainsi de  suite. Et s'il  n'y a  pas assez de  couleurs, on
boucle. Par exemple,  pour le jeu à 4 trous et  6 couleurs, le premier
coup  est  "ABCD",  le  deuxième  est "EFAB",  c'est-à-dire  les  deux
dernières couleurs  "E" et "F", puis  on reprend au début  avec "A" et
"B" pour compléter le code.

Tout  au long  du début  de partie,  si l'on  tombe sur  un  nombre de
marques à zéro, on supprime  carrément de la liste des couleurs celles
qui apparaissent dans la proposition. Cela accélérera l'interlude.

=head2 Interlude

Dans l'interlude,  le programme construit  la liste de tous  les codes
compatibles avec les coups joués pendant le début de partie.  La liste
est construite progressivement avec des  codes incomplets à 1, puis 2,
puis 3 pions, avant d'arriver aux codes complets à 4 pions.

À chaque  étape, on  compare le code  incomplet avec  les propositions
jouées dans le début de partie,  pour voir si les résultats (nombre de
marques noires et nombre de marques blanches) correspondent.  On garde
à l'esprit que le code est incomplet et qu'en le ajoutant une couleur,
on peut :

=over 4

=item * obtenir une marque noire supplémentaire,

=item * obtenir une marque blanche supplémentaire,

=item * remplacer une marque blanche par une marque noire.

=back

Pour un code à trois couleurs  et un vide, le nombre de marques noires
doit  donc être  le nombre  final, ou  bien le  nombre final  moins 1.
Quant à  tester les  marques blanches, il  est préférable de  faire la
somme noirs+blancs. Ainsi, le nombre  de marques noires et blanches du
code à trois couleurs et un  vide doit être le nombre final de marques
noires et blanches, ou bien ce nombre moins 1.

Pour  un code  à deux  couleurs et  deux vides,  le nombre  de marques
noires  doit être compris  entre le  nombre final  et le  nombre final
moins 2.  Idem pour la somme marques noires + marques blanches.

Et pour  un code  à une seule  couleur  et  trois vides, le  nombre de
marques noires  doit être compris entre  le nombre final  et le nombre
final moins 3.  Et encore une fois, c'est pareil pour le nombre cumulé
de marques noires et blanches.

Ainsi, en commençant  par déterminer les codes à un  seul pion, puis à
deux pions, puis 3 puis 4, on ne parcourt pas l'arbre entier des codes
possibles, on  l'élague au fur  et à mesure,  ce qui permet  de perdre
moins de temps.

Exemples : l'un  des coups joués était C<ABCD>,  noté C<X> (une marque
noire). Le code C<AE..> obtient  une note C<X> et est donc compatible.
Le  code C<AD..>  obtient une  note  C<XO> est  est incompatible.   En
effet,  quelles  que  soient  les  couleurs placées  en  troisième  et
quatrième positions,  on ne  pourra pas revenir  à une note  C<X>.  Le
code C<CE..> obtient une note C<O> et est compatible. Bien qu'il y ait
une marque blanche en trop, cette marque pourra être remplacée par une
marque  noire, lorsque l'on  testera C<CEC.>  puis C<CECC>  et C<CECE>
(entre autres).

Maintenant, supposons que le coup C<ABCD> ait reçu la note C<XOO> (une
marque noire et deux blanches). Le code C<AE..> reçoit la note C<X> et
est compatible.  En effet, il reste  deux trous à remplir  et ces deux
trous  peuvent  fournir  les  deux marques  blanches  manquantes.   En
revanche, le code  C<EF..> reçoit une note nulle  et est incompatible.
En effet,  ce n'est pas  les deux trous  à remplir qui  permettront de
fournir les trois marques manquantes.

Une fois  la liste  des codes construite,  le programme  évalue chaque
code avec  chaque autre, pour stocker  la note dans  un hachage indexé
par ces deux codes. Comme cela sera montré dans la suite, le programme
aura besoin de toutes ces notes  au moins une fois, mais assez souvent
plusieurs fois. À cause de cette étape, on souhaite avoir une liste de
codes  suffisamment  petite.   Il   aurait  été  possible  de  stocker
plusieurs centaines de codes possible dans la liste, mais pour l'étape
présente,  cela  aurait  impliqué  une  boucle avec  des  dizaines  de
milliers  d'itérations.   On préfère  donc,  autant  que possible,  se
limiter à quelques dizaines de codes possibles.

=head2 Fin de partie

À écrire

=head1 CONFIGURATION ET ENVIRONNEMENT

Néant.

=head1 DÉPENDANCES

À écrire

=head1 INCOMPATIBILITÉS

Aucune incompatibilité identifiée.

=head1 BOGUES ET LIMITES

Pour l'instant, aucun n'a été identifié.

=head1 AUTEUR

Jean Forget, JFORGET (à) cpan.org

=head1 LICENCE ET COPYRIGHT

(C) Jean Forget, 2011, tous droits réservés.

Les termes de licence de ce script sont les mêmes termes que pour Perl
: GNU General Public License (GPL) et Artistic License.



